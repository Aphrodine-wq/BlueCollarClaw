const Database = require('./database');
const BlueCollarClawNetwork = require('./network');
const NegotiationEngine = require('./negotiation');
const ContractGenerator = require('./contracts');
const { SimpleCalendar } = require('./calendar');
const { nanoid } = require('nanoid');
const path = require('path');

class BlueCollarClawAgent {
  constructor(contractorId, config = {}) {
    this.contractorId = contractorId;
    this.config = config;

    // Initialize components
    this.db = new Database(config.dbPath || './BlueCollarClaw.db');
    this.network = null;
    this.negotiation = new NegotiationEngine(this.db, contractorId);
    this.contracts = new ContractGenerator(config.contractsDir || path.join(__dirname, 'contracts'));
    this.calendar = new SimpleCalendar(); // Use simple calendar for MVP

    this.profile = null;
    this.isListening = false;
  }

  // Initialize the agent
  async initialize() {
    // Load contractor profile
    this.profile = await this.loadProfile();

    if (!this.profile) {
      throw new Error(`Contractor profile ${this.contractorId} not found. Run setup first.`);
    }

    // Connect to network
    this.network = new BlueCollarClawNetwork(
      this.config.mqttBroker || 'mqtt://localhost:1883',
      this.contractorId,
      (topic, message) => this.handleMessage(topic, message)
    );

    await this.network.connect();

    // Subscribe to personal channels
    this.network.subscribeToPersonalChannels();

    // Subscribe to trades
    if (this.profile.trades) {
      this.profile.trades.forEach(trade => {
        this.network.subscribe(trade.trade, this.profile.region || 'all');
      });
    }

    this.isListening = true;
    console.log(`BlueCollarClaw agent ${this.contractorId} initialized and listening`);
  }

  // Load contractor profile from database
  async loadProfile() {
    return new Promise((resolve, reject) => {
      this.db.getContractor(this.contractorId, (err, contractor) => {
        if (err) return reject(err);
        if (!contractor) return resolve(null);

        // Load trades
        this.db.getContractorTrades(this.contractorId, (err, trades) => {
          if (err) return reject(err);
          contractor.trades = trades || [];

          // TODO: Load service areas, rate preferences, availability
          contractor.serviceAreas = [];
          contractor.ratePreferences = [];
          contractor.availability = [];

          resolve(contractor);
        });
      });
    });
  }

  // Handle incoming network messages
  async handleMessage(topic, message) {
    console.log(`Received ${message.type} on ${topic}`);

    try {
      switch (message.type) {
        case 'REQUEST':
          await this.handleJobRequest(message);
          break;

        case 'OFFER':
          await this.handleOffer(message);
          break;

        case 'COUNTER':
          await this.handleCounter(message);
          break;

        case 'ACCEPT':
          await this.handleAcceptance(message);
          break;

        case 'DECLINE':
          await this.handleDecline(message);
          break;

        case 'CONFIRM':
          await this.handleConfirmation(message);
          break;

        default:
          console.warn(`Unknown message type: ${message.type}`);
      }
    } catch (err) {
      console.error('Error handling message:', err);
    }
  }

  // Handle incoming job request
  async handleJobRequest(request) {
    // Evaluate against profile
    const evaluation = await this.negotiation.evaluateRequest(request, this.profile);

    if (!evaluation.matches) {
      console.log(`Request ${request.id} does not match. Reasons: ${evaluation.reasons.join(', ')}`);
      return;
    }

    console.log(`Request ${request.id} matches! Score: ${evaluation.score}/100`);

    // Make decision
    const decision = await this.negotiation.makeDecision(request, evaluation, this.profile);

    switch (decision.action) {
      case 'ACCEPT':
        // Auto-send offer at suggested rate
        await this.sendOffer(request, evaluation.suggestedOffer);
        break;

      case 'COUNTER':
        // Send counter-offer
        await this.sendOffer(request, decision.counter);
        break;

      case 'SUGGEST':
      case 'NOTIFY':
        // Notify human (in real implementation, send to OpenClaw chat)
        console.log(`[HUMAN REVIEW NEEDED] Request ${request.id}:`, {
          trade: request.trade,
          location: request.location,
          rate: `$${request.minRate}-$${request.maxRate}/hr`,
          dates: `${request.startDate} to ${request.endDate}`,
          score: evaluation.score,
          suggested: evaluation.suggestedOffer,
        });
        break;

      case 'DECLINE':
        // Silently ignore
        console.log(`Declined request ${request.id}: ${decision.reason}`);
        break;
    }
  }

  // Send an offer
  async sendOffer(request, offerDetails) {
    const offerId = `offer_${nanoid()}`;

    const offer = {
      id: offerId,
      requestId: request.id,
      requesterId: request.requesterId,
      rate: offerDetails.rate,
      startDate: offerDetails.startDate,
      endDate: offerDetails.endDate,
      message: offerDetails.message || `Available at $${offerDetails.rate}/hr`,
      round: offerDetails.round || 1,
    };

    // Save to database
    this.db.createOffer(offer, (err) => {
      if (err) {
        console.error('Failed to save offer:', err);
        return;
      }

      // Send via network
      this.network.sendOffer(offer, this.profile.private_key);

      console.log(`Sent offer ${offerId} for request ${request.id} at $${offer.rate}/hr`);
    });
  }

  // Handle incoming offer (for GC)
  async handleOffer(offer) {
    // Get the original request
    this.db.getJobRequest(offer.requestId, async (err, request) => {
      if (err || !request) {
        console.error('Request not found for offer:', offer.requestId);
        return;
      }

      // Get contractor reputation
      this.db.getContractorReputation(offer.contractorId, (err, reputation) => {
        const offerWithReputation = { ...offer, reputation };

        console.log(`[OFFER RECEIVED] From ${offer.contractorId}:`, {
          rate: `$${offer.rate}/hr`,
          dates: `${offer.startDate} to ${offer.endDate}`,
          reputation: reputation ? `${reputation.average_score}â˜… (${reputation.total_ratings} jobs)` : 'No ratings yet',
        });

        // TODO: Auto-rank offers and notify human
        // For MVP, just log it
      });
    });
  }

  // Handle counter-offer
  async handleCounter(counter) {
    console.log(`[COUNTER-OFFER] Request ${counter.requestId}: $${counter.rate}/hr (Round ${counter.round})`);
    // TODO: Evaluate and respond
  }

  // Handle acceptance (booking confirmed)
  async handleAcceptance(acceptance) {
    // Get offer details
    this.db.getJobRequest(acceptance.requestId, async (err, request) => {
      if (err || !request) return;

      // Create booking
      const bookingId = `booking_${nanoid()}`;

      // Get offer details to finalize booking
      this.db.getOffersForRequest(acceptance.requestId, async (err, offers) => {
        const acceptedOffer = offers.find(o => o.id === acceptance.offerId);

        if (!acceptedOffer) {
          console.error('Accepted offer not found');
          return;
        }

        const booking = {
          id: bookingId,
          requestId: acceptance.requestId,
          offerId: acceptance.offerId,
          gcId: acceptance.requesterId,
          subId: acceptedOffer.contractor_id,
          trade: request.trade,
          location: request.location,
          startDate: acceptedOffer.start_date,
          endDate: acceptedOffer.end_date,
          rate: acceptedOffer.rate,
          scope: request.scope,
        };

        // Generate contract
        const gcInfo = { id: booking.gcId, name: 'GC Name' }; // TODO: Load from DB
        const subInfo = { id: booking.subId, name: acceptedOffer.contractor_name };

        const contractPath = await this.contracts.generateSubcontractorAgreement(
          booking,
          gcInfo,
          subInfo
        );

        booking.contractUrl = contractPath;

        // Create calendar event
        const calendarEventId = await this.calendar.createBookingEvent(
          booking,
          gcInfo,
          subInfo
        );

        booking.calendarEventId = calendarEventId;

        // Save booking
        this.db.createBooking(booking, (err) => {
          if (err) {
            console.error('Failed to create booking:', err);
            return;
          }

          console.log(`[BOOKING CONFIRMED] ${bookingId}`);
          console.log(`Contract: ${contractPath}`);
          console.log(`Calendar event: ${calendarEventId}`);

          // Send confirmation to both parties
          this.network.sendConfirmation({
            id: `conf_${nanoid()}`,
            bookingId,
            recipientId: acceptedOffer.contractor_id,
            contractUrl: contractPath,
            calendarEventId,
          }, this.profile.private_key);
        });
      });
    });
  }

  // Handle decline
  async handleDecline(decline) {
    console.log(`[OFFER DECLINED] Request ${decline.requestId}: ${decline.reason || 'No reason given'}`);

    this.db.updateOfferStatus(decline.offerId, 'declined', (err) => {
      if (err) console.error('Failed to update offer status:', err);
    });
  }

  // Handle booking confirmation
  async handleConfirmation(confirmation) {
    console.log(`[BOOKING CONFIRMED] ${confirmation.bookingId}`);
    console.log(`Contract URL: ${confirmation.contractUrl}`);
    console.log(`Calendar event: ${confirmation.calendarEventId}`);
  }

  // Public API: Broadcast a job request
  async broadcastJobRequest(requestDetails) {
    const requestId = `req_${nanoid()}`;

    const request = {
      id: requestId,
      requesterId: this.contractorId,
      trade: requestDetails.trade,
      location: requestDetails.location,
      latitude: requestDetails.latitude,
      longitude: requestDetails.longitude,
      startDate: requestDetails.startDate,
      endDate: requestDetails.endDate,
      minRate: requestDetails.minRate,
      maxRate: requestDetails.maxRate,
      scope: requestDetails.scope,
      requirements: requestDetails.requirements,
      region: requestDetails.region || 'all',
      created_at: Math.floor(Date.now() / 1000),
    };

    // Save to database
    this.db.createJobRequest(request, (err) => {
      if (err) {
        console.error('Failed to save job request:', err);
        return;
      }

      // Broadcast to network
      this.network.broadcastRequest(request, this.profile.private_key);

      console.log(`Broadcasted job request ${requestId} for ${request.trade}`);
    });

    return requestId;
  }

  // Public API: Accept an offer
  async acceptOffer(offerId) {
    const acceptance = {
      id: `accept_${nanoid()}`,
      offerId,
    };

    // Get offer details
    // TODO: Implement proper offer lookup

    this.network.sendAcceptance(acceptance, this.profile.private_key);
  }

  // Shutdown
  async shutdown() {
    if (this.network) {
      this.network.disconnect();
    }
    if (this.db) {
      this.db.close();
    }
    console.log('BlueCollarClaw agent shut down');
  }
}

module.exports = BlueCollarClawAgent;
